{
  "version": 3,
  "sources": ["../../@mouaad_idoufkir/why-render/src/engine/EventEmitter.ts", "../../@mouaad_idoufkir/why-render/src/engine/PerformanceMonitor.ts", "../../@mouaad_idoufkir/why-render/src/engine/RenderTracker.ts"],
  "sourcesContent": ["/**\n * Simple type-safe event emitter for render tracking events\n */\n\nimport type { RenderEvent } from '../types';\n\nexport type RenderEventType =\n    | 'render:start'\n    | 'render:end'\n    | 'change:detected'\n    | 'performance:warning'\n    | 'component:mounted'\n    | 'component:unmounted';\n\nexport interface RenderEventPayload {\n    'render:start': {\n        componentName: string;\n        componentId: string;\n        timestamp: number;\n    };\n    'render:end': {\n        componentName: string;\n        componentId: string;\n        renderEvent: RenderEvent;\n    };\n    'change:detected': {\n        componentName: string;\n        componentId: string;\n        changes: Array<{\n            key: string;\n            reason: string;\n            oldValue: any;\n            newValue: any;\n        }>;\n    };\n    'performance:warning': {\n        componentName: string;\n        componentId: string;\n        duration: number;\n        threshold: number;\n    };\n    'component:mounted': {\n        componentName: string;\n        componentId: string;\n    };\n    'component:unmounted': {\n        componentName: string;\n        componentId: string;\n    };\n}\n\ntype EventHandler<T extends RenderEventType> = (payload: RenderEventPayload[T]) => void;\n\nexport class EventEmitter {\n    private listeners: Map<RenderEventType, Set<EventHandler<any>>> = new Map();\n\n    /**\n     * Subscribe to an event\n     */\n    on<T extends RenderEventType>(event: T, handler: EventHandler<T>): () => void {\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, new Set());\n        }\n\n        this.listeners.get(event)!.add(handler);\n\n        // Return unsubscribe function\n        return () => this.off(event, handler);\n    }\n\n    /**\n     * Unsubscribe from an event\n     */\n    off<T extends RenderEventType>(event: T, handler: EventHandler<T>): void {\n        const handlers = this.listeners.get(event);\n        if (handlers) {\n            handlers.delete(handler);\n        }\n    }\n\n    /**\n     * Emit an event to all subscribers\n     */\n    emit<T extends RenderEventType>(event: T, payload: RenderEventPayload[T]): void {\n        const handlers = this.listeners.get(event);\n        if (handlers) {\n            handlers.forEach(handler => {\n                try {\n                    handler(payload);\n                } catch (error) {\n                    console.error(`[why-render] Error in event handler for ${event}:`, error);\n                }\n            });\n        }\n    }\n\n    /**\n     * Subscribe to an event once (auto-unsubscribe after first call)\n     */\n    once<T extends RenderEventType>(event: T, handler: EventHandler<T>): () => void {\n        const wrappedHandler = (payload: RenderEventPayload[T]) => {\n            handler(payload);\n            this.off(event, wrappedHandler);\n        };\n\n        return this.on(event, wrappedHandler as EventHandler<T>);\n    }\n\n    /**\n     * Remove all listeners for a specific event or all events\n     */\n    clear(event?: RenderEventType): void {\n        if (event) {\n            this.listeners.delete(event);\n        } else {\n            this.listeners.clear();\n        }\n    }\n\n    /**\n     * Get listener count for an event\n     */\n    listenerCount(event: RenderEventType): number {\n        return this.listeners.get(event)?.size ?? 0;\n    }\n}\n\n// Global singleton instance\nexport const globalEventEmitter = new EventEmitter();\n", "/**\n * Performance monitoring for React components\n * Tracks render duration, detects slow renders, monitors transitions\n */\n\nimport { globalEventEmitter } from './EventEmitter';\n\nexport interface PerformanceMetrics {\n    componentName: string;\n    componentId: string;\n    renderCount: number;\n    totalTime: number;\n    averageTime: number;\n    lastRenderTime: number;\n    slowRenders: number;\n    maxRenderTime: number;\n    minRenderTime: number;\n}\n\nexport interface PerformanceOptions {\n    slowThresholdMs?: number;\n    enableMarks?: boolean;\n}\n\nconst DEFAULT_SLOW_THRESHOLD = 16; // 16ms (one frame at 60fps)\n\nexport class PerformanceMonitor {\n    private metrics: Map<string, PerformanceMetrics> = new Map();\n    private activeRenders: Map<string, number> = new Map();\n    private options: Required<PerformanceOptions>;\n\n    constructor(options: PerformanceOptions = {}) {\n        this.options = {\n            slowThresholdMs: options.slowThresholdMs ?? DEFAULT_SLOW_THRESHOLD,\n            enableMarks: options.enableMarks ?? false,\n        };\n    }\n\n    /**\n     * Mark the start of a component render\n     */\n    markRenderStart(componentName: string, componentId: string): void {\n        const timestamp = performance.now();\n        this.activeRenders.set(componentId, timestamp);\n\n        if (this.options.enableMarks) {\n            performance.mark(`${componentName}:${componentId}:start`);\n        }\n\n        globalEventEmitter.emit('render:start', {\n            componentName,\n            componentId,\n            timestamp,\n        });\n    }\n\n    /**\n     * Mark the end of a component render and record metrics\n     */\n    markRenderEnd(componentName: string, componentId: string): number {\n        const endTime = performance.now();\n        const startTime = this.activeRenders.get(componentId);\n\n        if (!startTime) {\n            console.warn(`[why-render] No start time found for ${componentName}:${componentId}`);\n            return 0;\n        }\n\n        const duration = endTime - startTime;\n        this.activeRenders.delete(componentId);\n\n        if (this.options.enableMarks) {\n            const markName = `${componentName}:${componentId}`;\n            performance.mark(`${markName}:end`);\n            performance.measure(markName, `${markName}:start`, `${markName}:end`);\n        }\n\n        // Update metrics\n        this.updateMetrics(componentName, componentId, duration);\n\n        // Check for slow render\n        if (duration > this.options.slowThresholdMs) {\n            globalEventEmitter.emit('performance:warning', {\n                componentName,\n                componentId,\n                duration,\n                threshold: this.options.slowThresholdMs,\n            });\n        }\n\n        return duration;\n    }\n\n    /**\n     * Update performance metrics for a component\n     */\n    private updateMetrics(componentName: string, componentId: string, duration: number): void {\n        const existing = this.metrics.get(componentId);\n\n        if (existing) {\n            const newRenderCount = existing.renderCount + 1;\n            const newTotalTime = existing.totalTime + duration;\n\n            this.metrics.set(componentId, {\n                componentName,\n                componentId,\n                renderCount: newRenderCount,\n                totalTime: newTotalTime,\n                averageTime: newTotalTime / newRenderCount,\n                lastRenderTime: duration,\n                slowRenders: duration > this.options.slowThresholdMs\n                    ? existing.slowRenders + 1\n                    : existing.slowRenders,\n                maxRenderTime: Math.max(existing.maxRenderTime, duration),\n                minRenderTime: Math.min(existing.minRenderTime, duration),\n            });\n        } else {\n            this.metrics.set(componentId, {\n                componentName,\n                componentId,\n                renderCount: 1,\n                totalTime: duration,\n                averageTime: duration,\n                lastRenderTime: duration,\n                slowRenders: duration > this.options.slowThresholdMs ? 1 : 0,\n                maxRenderTime: duration,\n                minRenderTime: duration,\n            });\n        }\n    }\n\n    /**\n     * Get metrics for a specific component\n     */\n    getMetrics(componentId: string): PerformanceMetrics | undefined {\n        return this.metrics.get(componentId);\n    }\n\n    /**\n     * Get all metrics\n     */\n    getAllMetrics(): PerformanceMetrics[] {\n        return Array.from(this.metrics.values());\n    }\n\n    /**\n     * Get components sorted by total render time\n     */\n    getSlowestComponents(limit: number = 10): PerformanceMetrics[] {\n        return Array.from(this.metrics.values())\n            .sort((a, b) => b.totalTime - a.totalTime)\n            .slice(0, limit);\n    }\n\n    /**\n     * Get components with most renders\n     */\n    getMostRenderedComponents(limit: number = 10): PerformanceMetrics[] {\n        return Array.from(this.metrics.values())\n            .sort((a, b) => b.renderCount - a.renderCount)\n            .slice(0, limit);\n    }\n\n    /**\n     * Clear metrics for a component or all components\n     */\n    clearMetrics(componentId?: string): void {\n        if (componentId) {\n            this.metrics.delete(componentId);\n        } else {\n            this.metrics.clear();\n        }\n    }\n\n    /**\n     * Update slow threshold\n     */\n    setSlowThreshold(thresholdMs: number): void {\n        this.options.slowThresholdMs = thresholdMs;\n    }\n}\n\n// Global singleton instance\nexport const globalPerformanceMonitor = new PerformanceMonitor();\n", "/**\n * Core render tracking engine\n * Tracks component renders, prop changes, and maintains render history\n */\n\nimport { globalEventEmitter } from './EventEmitter';\nimport { globalPerformanceMonitor } from './PerformanceMonitor';\nimport type { Change, RenderEvent } from '../types';\n\nexport interface ComponentHierarchyNode {\n    componentName: string;\n    componentId: string;\n    children: ComponentHierarchyNode[];\n    parent?: ComponentHierarchyNode;\n    depth: number;\n}\n\nexport class RenderTracker {\n    private renderHistory: Map<string, RenderEvent> = new Map();\n    private componentHierarchy: Map<string, ComponentHierarchyNode> = new Map();\n    private componentRenderCounts: Map<string, number> = new Map();\n    private maxHistorySize: number;\n\n    constructor(maxHistorySize: number = 1000) {\n        this.maxHistorySize = maxHistorySize;\n    }\n\n    /**\n     * Track a component render\n     */\n    trackRender(\n        componentName: string,\n        componentId: string,\n        props: any,\n        changes: Change[]\n    ): void {\n        const timestamp = performance.now();\n\n        // Start performance monitoring\n        globalPerformanceMonitor.markRenderStart(componentName, componentId);\n\n        // Update render count\n        const renderCount = (this.componentRenderCounts.get(componentId) ?? 0) + 1;\n        this.componentRenderCounts.set(componentId, renderCount);\n\n        // Emit changes if any\n        if (changes.length > 0) {\n            globalEventEmitter.emit('change:detected', {\n                componentName,\n                componentId,\n                changes,\n            });\n        }\n\n        // Record render event (will be completed in commitRender)\n        const eventId = `${componentId}-${timestamp}`;\n        this.renderHistory.set(eventId, {\n            id: eventId,\n            componentName,\n            componentId,\n            timestamp,\n            duration: 0, // Will be set in commitRender\n            changes,\n            props,\n            renderCount,\n        });\n\n        // Maintain history size\n        if (this.renderHistory.size > this.maxHistorySize) {\n            const firstKey = this.renderHistory.keys().next().value;\n            if (firstKey) {\n                this.renderHistory.delete(firstKey);\n            }\n        }\n    }\n\n    /**\n     * Commit a render (called after render completes)\n     */\n    commitRender(componentName: string, componentId: string): void {\n        const duration = globalPerformanceMonitor.markRenderEnd(componentName, componentId);\n\n        // Update the most recent render event with duration\n        const recentEvent = Array.from(this.renderHistory.values())\n            .reverse()\n            .find(event => event.componentId === componentId);\n\n        if (recentEvent) {\n            recentEvent.duration = duration;\n\n            console.log('[RenderTracker] Emitting render:end event:', {\n                componentName,\n                componentId,\n                eventId: recentEvent.id,\n                duration: recentEvent.duration,\n            });\n            globalEventEmitter.emit('render:end', {\n                componentName,\n                componentId,\n                renderEvent: recentEvent,\n            });\n        }\n    }\n\n    /**\n     * Register a component in the hierarchy\n     */\n    registerComponent(\n        componentName: string,\n        componentId: string,\n        parentId?: string\n    ): void {\n        const parent = parentId ? this.componentHierarchy.get(parentId) : undefined;\n        const depth = parent ? parent.depth + 1 : 0;\n\n        const node: ComponentHierarchyNode = {\n            componentName,\n            componentId,\n            children: [],\n            parent,\n            depth,\n        };\n\n        this.componentHierarchy.set(componentId, node);\n\n        if (parent) {\n            parent.children.push(node);\n        }\n\n        globalEventEmitter.emit('component:mounted', {\n            componentName,\n            componentId,\n        });\n    }\n\n    /**\n     * Unregister a component from the hierarchy\n     */\n    unregisterComponent(componentId: string): void {\n        const node = this.componentHierarchy.get(componentId);\n\n        if (node) {\n            // Remove from parent's children\n            if (node.parent) {\n                node.parent.children = node.parent.children.filter(\n                    child => child.componentId !== componentId\n                );\n            }\n\n            this.componentHierarchy.delete(componentId);\n\n            globalEventEmitter.emit('component:unmounted', {\n                componentName: node.componentName,\n                componentId,\n            });\n        }\n    }\n\n    /**\n     * Get render history for a component\n     */\n    getComponentHistory(componentId: string): RenderEvent[] {\n        return Array.from(this.renderHistory.values())\n            .filter(event => event.componentId === componentId)\n            .sort((a, b) => a.timestamp - b.timestamp);\n    }\n\n    /**\n     * Get all render history\n     */\n    getAllHistory(): RenderEvent[] {\n        return Array.from(this.renderHistory.values())\n            .sort((a, b) => a.timestamp - b.timestamp);\n    }\n\n    /**\n     * Get recent renders (last N)\n     */\n    getRecentRenders(limit: number = 50): RenderEvent[] {\n        return Array.from(this.renderHistory.values())\n            .sort((a, b) => b.timestamp - a.timestamp)\n            .slice(0, limit);\n    }\n\n    /**\n     * Get component hierarchy tree\n     */\n    getHierarchy(): ComponentHierarchyNode[] {\n        return Array.from(this.componentHierarchy.values())\n            .filter(node => !node.parent);\n    }\n\n    /**\n     * Get a specific component node\n     */\n    getComponentNode(componentId: string): ComponentHierarchyNode | undefined {\n        return this.componentHierarchy.get(componentId);\n    }\n\n    /**\n     * Get render count for a component\n     */\n    getRenderCount(componentId: string): number {\n        return this.componentRenderCounts.get(componentId) ?? 0;\n    }\n\n    /**\n     * Clear all tracking data\n     */\n    clear(): void {\n        this.renderHistory.clear();\n        this.componentHierarchy.clear();\n        this.componentRenderCounts.clear();\n        globalPerformanceMonitor.clearMetrics();\n    }\n\n    /**\n     * Export data for debugging/reports\n     */\n    export(): {\n        history: RenderEvent[];\n        hierarchy: ComponentHierarchyNode[];\n        metrics: ReturnType<typeof globalPerformanceMonitor.getAllMetrics>;\n    } {\n        return {\n            history: this.getAllHistory(),\n            hierarchy: this.getHierarchy(),\n            metrics: globalPerformanceMonitor.getAllMetrics(),\n        };\n    }\n}\n\n// Global singleton instance\nexport const globalRenderTracker = new RenderTracker();\n"],
  "mappings": "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",
  "names": []
}
