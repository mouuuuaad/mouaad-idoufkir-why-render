{"version":3,"sources":["../src/utils/diff.ts","../src/utils/env.ts","../src/hooks/useWhyRender.ts","../src/hoc/withWhyRender.tsx","../src/index.ts"],"names":["useRef","useEffect","forwardRef","jsx"],"mappings":"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","file":"index.cjs","sourcesContent":["import { Change, CompareStrategy } from '../types';\n\nfunction isObject(x: any): x is object {\n    return typeof x === 'object' && x !== null;\n}\n\nfunction fastDeepEqual(a: any, b: any, depth: number = 3): boolean {\n    if (depth < 0) return true; // Stop recursion, assume equal to avoid perf hit\n    if (Object.is(a, b)) return true;\n\n    if (!isObject(a) || !isObject(b)) return false;\n    if (Array.isArray(a) !== Array.isArray(b)) return false;\n\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) return false;\n\n    for (const key of keysA) {\n        if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n        if (!fastDeepEqual((a as any)[key], (b as any)[key], depth - 1)) return false;\n    }\n\n    return true;\n}\n\nfunction deepEqual(a: any, b: any): boolean {\n    // Try structuredClone for deep copy comparison if available (modern browsers/Node)\n    // But structuredClone copies, it doesn't compare.\n    // We can use a recursive comparator that handles cycles if needed, \n    // or just JSON.stringify if we assume no cycles/functions for \"deep\" data.\n    // Requirement says: \"use user-provided structuredClone + JSON compare or a controlled recursive comparator\"\n    try {\n        return JSON.stringify(a) === JSON.stringify(b);\n    } catch (e) {\n        // Fallback to fastDeepEqual with higher depth if JSON fails (e.g. circular)\n        return fastDeepEqual(a, b, 10);\n    }\n}\n\nexport function getChanges(\n    prevProps: any,\n    nextProps: any,\n    strategy: CompareStrategy,\n    customCompare?: (a: any, b: any) => boolean,\n    skipKeys: string[] = []\n): Change[] {\n    const changes: Change[] = [];\n    const allKeys = new Set([...Object.keys(prevProps || {}), ...Object.keys(nextProps || {})]);\n\n    for (const key of allKeys) {\n        if (skipKeys.includes(key)) continue;\n\n        const prev = prevProps ? prevProps[key] : undefined;\n        const next = nextProps ? nextProps[key] : undefined;\n\n        if (Object.is(prev, next)) {\n            continue;\n        }\n\n        if (customCompare && customCompare(prev, next)) {\n            continue;\n        }\n\n        let reason: Change['reason'] = 'value';\n        let areDeepEqual = false;\n\n        if (typeof prev !== typeof next) {\n            reason = 'type';\n        } else if (typeof prev === 'function') {\n            reason = 'function';\n        } else if (Array.isArray(prev) && Array.isArray(next) && prev.length !== next.length) {\n            reason = 'length';\n        } else if (isObject(prev) && isObject(next)) {\n            // It's an object/array reference change\n            if (strategy === 'deep') {\n                areDeepEqual = deepEqual(prev, next);\n            } else if (strategy === 'fast-deep') {\n                areDeepEqual = fastDeepEqual(prev, next);\n            } else {\n                // shallow strategy: we already know they are not Object.is, so they are different refs\n                areDeepEqual = false;\n            }\n\n            if (areDeepEqual) {\n                reason = 'reference';\n            } else {\n                reason = 'value'; // Deeply different\n            }\n        }\n\n        changes.push({\n            key,\n            reason,\n            oldValue: prev,\n            newValue: next,\n        });\n    }\n\n    return changes;\n}\n","export function shouldInstrument(): boolean {\n    if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n        return true;\n    }\n    if (typeof window !== 'undefined' && (window as any).__WHY_RENDER__ === true) {\n        return true;\n    }\n    return false;\n}\n","import { useRef, useEffect } from 'react';\nimport { Options, Change } from '../types';\nimport { getChanges } from '../utils/diff';\nimport { shouldInstrument } from '../utils/env';\n\n// Global registry for tracking (WeakMap keyed by a unique symbol per component instance)\nconst componentRegistry = new WeakMap<object, string>();\n\nexport function useWhyRender<TProps = any>(\n    props: TProps,\n    componentName?: string,\n    options?: Options\n): { lastProps: TProps | null; changes: Change[] } {\n    if (!shouldInstrument()) {\n        return { lastProps: null, changes: [] };\n    }\n\n    // Stable ID for this component instance\n    // We use a ref to hold a symbol that represents this instance \"identity\"\n    const idRef = useRef<object>(null);\n    if (!idRef.current) {\n        idRef.current = {}; // Unique object as key\n    }\n\n    const lastProps = useRef<TProps | null>(null);\n    const changesRef = useRef<Change[]>([]);\n    const renderCount = useRef(0);\n\n    const name = componentName || 'Component';\n    const strategy = options?.compareStrategy || 'shallow';\n\n    // Calculate changes during render\n    if (lastProps.current) {\n        changesRef.current = getChanges(\n            lastProps.current,\n            props,\n            strategy,\n            options?.customCompare,\n            options?.skipKeys\n        );\n\n        if (changesRef.current.length > 0) {\n            const msg = `[why-render] ${name} re-rendered because: ${changesRef.current.map(c => c.key).join(', ')}`;\n            console.warn(msg);\n\n            if (options?.verbose) {\n                console.groupCollapsed(`[why-render] ${name} details`);\n                changesRef.current.forEach(change => {\n                    // Truncate long values for display\n                    const formatVal = (v: any) => {\n                        try {\n                            const s = typeof v === 'string' ? v : JSON.stringify(v);\n                            return s && s.length > 1000 ? s.slice(0, 1000) + '...' : s;\n                        } catch { return String(v); }\n                    };\n\n                    console.log(`Prop '${change.key}':`, {\n                        ...change,\n                        oldValue: formatVal(change.oldValue),\n                        newValue: formatVal(change.newValue)\n                    });\n\n                    if (change.reason === 'function') {\n                        console.log('Tip: Wrap with useCallback');\n                    } else if (change.reason === 'reference') {\n                        console.log('Tip: Memoize object/array or move outside component');\n                    }\n                });\n                console.groupEnd();\n            }\n        }\n    }\n\n    renderCount.current++;\n\n    // Commit phase: update lastProps\n    useEffect(() => {\n        lastProps.current = props;\n    });\n\n    // Register for tracking if needed\n    useEffect(() => {\n        if (idRef.current) {\n            componentRegistry.set(idRef.current, name);\n        }\n    }, [name]);\n\n    return {\n        lastProps: lastProps.current,\n        changes: changesRef.current\n    };\n}\n\n// Static-like method to get the token (not directly attached to function due to ESM, but exported separately if needed)\n// Or we can attach it if we change export style. \n// Requirement: \"Provide an opt-in useWhyRender.track()\"\n// We can assign it to the function object.\n(useWhyRender as any).track = () => {\n    // This is tricky because hooks rely on call context. \n    // If the user calls `useWhyRender.track()` inside a component, it's just a function.\n    // It probably needs to be a separate hook `useWhyRenderTrack` or return a token from the main hook.\n    // Re-reading requirement: \"Provide an opt-in useWhyRender.track() that returns a small token\"\n    // Maybe they mean the return value of the hook has a track method? Or it's a separate function on the export?\n    // \"useWhyRender.track()\" looks like a static method.\n    // But to work it needs access to the instance. \n    // I will implement a separate hook `useTrackWhyRender` or just return the token from `useWhyRender` if requested?\n    // Let's stick to the simplest interpretation: A static helper that generates a token?\n    // Actually, if I attach it to the function, I can't use hook state inside it unless it's also a hook.\n    // I'll implement it as a property on the function that returns a unique symbol/token.\n    return Symbol('why-render-token');\n};\n","import React, { forwardRef } from 'react';\nimport { Options } from '../types';\nimport { useWhyRender } from '../hooks/useWhyRender';\n\nexport function withWhyRender<TProps extends object>(\n    Component: React.ComponentType<TProps>,\n    options?: Options\n): React.FC<TProps> {\n    const WrappedComponent = forwardRef<any, TProps>((props, ref) => {\n        const componentName = Component.displayName || Component.name || 'Component';\n        useWhyRender(props, componentName, options);\n\n        return <Component {...props as any} ref={ref} />;\n    });\n\n    WrappedComponent.displayName = `withWhyRender(${Component.displayName || Component.name || 'Component'})`;\n    return WrappedComponent as unknown as React.FC<TProps>;\n}\n","import { useWhyRender } from './hooks/useWhyRender';\nimport { withWhyRender } from './hoc/withWhyRender';\nimport { Options, CompareStrategy, Change } from './types';\n\n// Augment the function type to include track\nexport type UseWhyRender = typeof useWhyRender & { track: () => symbol };\n\nconst useWhyRenderExport = useWhyRender as UseWhyRender;\n\nexport { useWhyRenderExport as useWhyRender };\nexport { withWhyRender };\nexport type { Options, CompareStrategy, Change };\n"]}