{"version":3,"sources":["/home/mouaadid/Desktop/why-render/dist/chunk-DDU7LFC6.cjs","../src/engine/PerformanceMonitor.ts","../src/engine/RenderTracker.ts"],"names":[],"mappings":"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","file":"/home/mouaadid/Desktop/why-render/dist/chunk-DDU7LFC6.cjs","sourcesContent":[null,"/**\n * Performance monitoring for React components\n * Tracks render duration, detects slow renders, monitors transitions\n */\n\nimport { globalEventEmitter } from './EventEmitter';\n\nexport interface PerformanceMetrics {\n    componentName: string;\n    componentId: string;\n    renderCount: number;\n    totalTime: number;\n    averageTime: number;\n    lastRenderTime: number;\n    slowRenders: number;\n    maxRenderTime: number;\n    minRenderTime: number;\n}\n\nexport interface PerformanceOptions {\n    slowThresholdMs?: number;\n    enableMarks?: boolean;\n}\n\nconst DEFAULT_SLOW_THRESHOLD = 16; // 16ms (one frame at 60fps)\n\nexport class PerformanceMonitor {\n    private metrics: Map<string, PerformanceMetrics> = new Map();\n    private activeRenders: Map<string, number> = new Map();\n    private options: Required<PerformanceOptions>;\n\n    constructor(options: PerformanceOptions = {}) {\n        this.options = {\n            slowThresholdMs: options.slowThresholdMs ?? DEFAULT_SLOW_THRESHOLD,\n            enableMarks: options.enableMarks ?? false,\n        };\n    }\n\n    /**\n     * Mark the start of a component render\n     */\n    markRenderStart(componentName: string, componentId: string): void {\n        const timestamp = performance.now();\n        this.activeRenders.set(componentId, timestamp);\n\n        if (this.options.enableMarks) {\n            performance.mark(`${componentName}:${componentId}:start`);\n        }\n\n        globalEventEmitter.emit('render:start', {\n            componentName,\n            componentId,\n            timestamp,\n        });\n    }\n\n    /**\n     * Mark the end of a component render and record metrics\n     */\n    markRenderEnd(componentName: string, componentId: string): number {\n        const endTime = performance.now();\n        const startTime = this.activeRenders.get(componentId);\n\n        if (!startTime) {\n            console.warn(`[why-render] No start time found for ${componentName}:${componentId}`);\n            return 0;\n        }\n\n        const duration = endTime - startTime;\n        this.activeRenders.delete(componentId);\n\n        if (this.options.enableMarks) {\n            const markName = `${componentName}:${componentId}`;\n            performance.mark(`${markName}:end`);\n            performance.measure(markName, `${markName}:start`, `${markName}:end`);\n        }\n\n        // Update metrics\n        this.updateMetrics(componentName, componentId, duration);\n\n        // Check for slow render\n        if (duration > this.options.slowThresholdMs) {\n            globalEventEmitter.emit('performance:warning', {\n                componentName,\n                componentId,\n                duration,\n                threshold: this.options.slowThresholdMs,\n            });\n        }\n\n        return duration;\n    }\n\n    /**\n     * Update performance metrics for a component\n     */\n    private updateMetrics(componentName: string, componentId: string, duration: number): void {\n        const existing = this.metrics.get(componentId);\n\n        if (existing) {\n            const newRenderCount = existing.renderCount + 1;\n            const newTotalTime = existing.totalTime + duration;\n\n            this.metrics.set(componentId, {\n                componentName,\n                componentId,\n                renderCount: newRenderCount,\n                totalTime: newTotalTime,\n                averageTime: newTotalTime / newRenderCount,\n                lastRenderTime: duration,\n                slowRenders: duration > this.options.slowThresholdMs\n                    ? existing.slowRenders + 1\n                    : existing.slowRenders,\n                maxRenderTime: Math.max(existing.maxRenderTime, duration),\n                minRenderTime: Math.min(existing.minRenderTime, duration),\n            });\n        } else {\n            this.metrics.set(componentId, {\n                componentName,\n                componentId,\n                renderCount: 1,\n                totalTime: duration,\n                averageTime: duration,\n                lastRenderTime: duration,\n                slowRenders: duration > this.options.slowThresholdMs ? 1 : 0,\n                maxRenderTime: duration,\n                minRenderTime: duration,\n            });\n        }\n    }\n\n    /**\n     * Get metrics for a specific component\n     */\n    getMetrics(componentId: string): PerformanceMetrics | undefined {\n        return this.metrics.get(componentId);\n    }\n\n    /**\n     * Get all metrics\n     */\n    getAllMetrics(): PerformanceMetrics[] {\n        return Array.from(this.metrics.values());\n    }\n\n    /**\n     * Get components sorted by total render time\n     */\n    getSlowestComponents(limit: number = 10): PerformanceMetrics[] {\n        return Array.from(this.metrics.values())\n            .sort((a, b) => b.totalTime - a.totalTime)\n            .slice(0, limit);\n    }\n\n    /**\n     * Get components with most renders\n     */\n    getMostRenderedComponents(limit: number = 10): PerformanceMetrics[] {\n        return Array.from(this.metrics.values())\n            .sort((a, b) => b.renderCount - a.renderCount)\n            .slice(0, limit);\n    }\n\n    /**\n     * Clear metrics for a component or all components\n     */\n    clearMetrics(componentId?: string): void {\n        if (componentId) {\n            this.metrics.delete(componentId);\n        } else {\n            this.metrics.clear();\n        }\n    }\n\n    /**\n     * Update slow threshold\n     */\n    setSlowThreshold(thresholdMs: number): void {\n        this.options.slowThresholdMs = thresholdMs;\n    }\n}\n\n// Global singleton instance\nexport const globalPerformanceMonitor = new PerformanceMonitor();\n","/**\n * Core render tracking engine\n * Tracks component renders, prop changes, and maintains render history\n */\n\nimport { globalEventEmitter } from './EventEmitter';\nimport { globalPerformanceMonitor } from './PerformanceMonitor';\nimport type { Change, RenderEvent } from '../types';\n\nexport interface ComponentHierarchyNode {\n    componentName: string;\n    componentId: string;\n    children: ComponentHierarchyNode[];\n    parent?: ComponentHierarchyNode;\n    depth: number;\n}\n\nexport class RenderTracker {\n    private renderHistory: Map<string, RenderEvent> = new Map();\n    private componentHierarchy: Map<string, ComponentHierarchyNode> = new Map();\n    private componentRenderCounts: Map<string, number> = new Map();\n    private maxHistorySize: number;\n\n    constructor(maxHistorySize: number = 1000) {\n        this.maxHistorySize = maxHistorySize;\n    }\n\n    /**\n     * Track a component render\n     */\n    trackRender(\n        componentName: string,\n        componentId: string,\n        props: any,\n        changes: Change[]\n    ): void {\n        const timestamp = performance.now();\n\n        // Start performance monitoring\n        globalPerformanceMonitor.markRenderStart(componentName, componentId);\n\n        // Update render count\n        const renderCount = (this.componentRenderCounts.get(componentId) ?? 0) + 1;\n        this.componentRenderCounts.set(componentId, renderCount);\n\n        // Emit changes if any\n        if (changes.length > 0) {\n            globalEventEmitter.emit('change:detected', {\n                componentName,\n                componentId,\n                changes,\n            });\n        }\n\n        // Record render event (will be completed in commitRender)\n        const eventId = `${componentId}-${timestamp}`;\n        this.renderHistory.set(eventId, {\n            id: eventId,\n            componentName,\n            componentId,\n            timestamp,\n            duration: 0, // Will be set in commitRender\n            changes,\n            props,\n            renderCount,\n        });\n\n        // Maintain history size\n        if (this.renderHistory.size > this.maxHistorySize) {\n            const firstKey = this.renderHistory.keys().next().value;\n            if (firstKey) {\n                this.renderHistory.delete(firstKey);\n            }\n        }\n    }\n\n    /**\n     * Commit a render (called after render completes)\n     */\n    commitRender(componentName: string, componentId: string): void {\n        const duration = globalPerformanceMonitor.markRenderEnd(componentName, componentId);\n\n        // Update the most recent render event with duration\n        const recentEvent = Array.from(this.renderHistory.values())\n            .reverse()\n            .find(event => event.componentId === componentId);\n\n        if (recentEvent) {\n            recentEvent.duration = duration;\n\n            console.log('[RenderTracker] Emitting render:end event:', {\n                componentName,\n                componentId,\n                eventId: recentEvent.id,\n                duration: recentEvent.duration,\n            });\n            globalEventEmitter.emit('render:end', {\n                componentName,\n                componentId,\n                renderEvent: recentEvent,\n            });\n        }\n    }\n\n    /**\n     * Register a component in the hierarchy\n     */\n    registerComponent(\n        componentName: string,\n        componentId: string,\n        parentId?: string\n    ): void {\n        const parent = parentId ? this.componentHierarchy.get(parentId) : undefined;\n        const depth = parent ? parent.depth + 1 : 0;\n\n        const node: ComponentHierarchyNode = {\n            componentName,\n            componentId,\n            children: [],\n            parent,\n            depth,\n        };\n\n        this.componentHierarchy.set(componentId, node);\n\n        if (parent) {\n            parent.children.push(node);\n        }\n\n        globalEventEmitter.emit('component:mounted', {\n            componentName,\n            componentId,\n        });\n    }\n\n    /**\n     * Unregister a component from the hierarchy\n     */\n    unregisterComponent(componentId: string): void {\n        const node = this.componentHierarchy.get(componentId);\n\n        if (node) {\n            // Remove from parent's children\n            if (node.parent) {\n                node.parent.children = node.parent.children.filter(\n                    child => child.componentId !== componentId\n                );\n            }\n\n            this.componentHierarchy.delete(componentId);\n\n            globalEventEmitter.emit('component:unmounted', {\n                componentName: node.componentName,\n                componentId,\n            });\n        }\n    }\n\n    /**\n     * Get render history for a component\n     */\n    getComponentHistory(componentId: string): RenderEvent[] {\n        return Array.from(this.renderHistory.values())\n            .filter(event => event.componentId === componentId)\n            .sort((a, b) => a.timestamp - b.timestamp);\n    }\n\n    /**\n     * Get all render history\n     */\n    getAllHistory(): RenderEvent[] {\n        return Array.from(this.renderHistory.values())\n            .sort((a, b) => a.timestamp - b.timestamp);\n    }\n\n    /**\n     * Get recent renders (last N)\n     */\n    getRecentRenders(limit: number = 50): RenderEvent[] {\n        return Array.from(this.renderHistory.values())\n            .sort((a, b) => b.timestamp - a.timestamp)\n            .slice(0, limit);\n    }\n\n    /**\n     * Get component hierarchy tree\n     */\n    getHierarchy(): ComponentHierarchyNode[] {\n        return Array.from(this.componentHierarchy.values())\n            .filter(node => !node.parent);\n    }\n\n    /**\n     * Get a specific component node\n     */\n    getComponentNode(componentId: string): ComponentHierarchyNode | undefined {\n        return this.componentHierarchy.get(componentId);\n    }\n\n    /**\n     * Get render count for a component\n     */\n    getRenderCount(componentId: string): number {\n        return this.componentRenderCounts.get(componentId) ?? 0;\n    }\n\n    /**\n     * Clear all tracking data\n     */\n    clear(): void {\n        this.renderHistory.clear();\n        this.componentHierarchy.clear();\n        this.componentRenderCounts.clear();\n        globalPerformanceMonitor.clearMetrics();\n    }\n\n    /**\n     * Export data for debugging/reports\n     */\n    export(): {\n        history: RenderEvent[];\n        hierarchy: ComponentHierarchyNode[];\n        metrics: ReturnType<typeof globalPerformanceMonitor.getAllMetrics>;\n    } {\n        return {\n            history: this.getAllHistory(),\n            hierarchy: this.getHierarchy(),\n            metrics: globalPerformanceMonitor.getAllMetrics(),\n        };\n    }\n}\n\n// Global singleton instance\nexport const globalRenderTracker = new RenderTracker();\n"]}