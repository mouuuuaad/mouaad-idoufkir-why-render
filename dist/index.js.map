{"version":3,"sources":["../src/hooks/useWhyRender.ts","../src/utils/diff.ts","../src/utils/env.ts","../src/engine/EventEmitter.ts","../src/engine/PerformanceMonitor.ts","../src/engine/RenderTracker.ts","../src/hoc/withWhyRender.tsx","../src/index.ts"],"sourcesContent":["import { useRef, useEffect } from 'react';\nimport { Options, Change } from '../types';\nimport { getChanges } from '../utils/diff';\nimport { shouldInstrument } from '../utils/env';\nimport { globalRenderTracker } from '../engine/RenderTracker';\nimport { globalPerformanceMonitor } from '../engine/PerformanceMonitor';\n\n// Generate stable component IDs\nlet componentIdCounter = 0;\nconst generateComponentId = (name: string): string => {\n    return `${name}-${++componentIdCounter}-${Date.now()}`;\n};\n\nexport function useWhyRender<TProps = any>(\n    props: TProps,\n    componentName?: string,\n    options?: Options\n): { lastProps: TProps | null; changes: Change[]; componentId: string } {\n    if (!shouldInstrument()) {\n        return { lastProps: null, changes: [], componentId: '' };\n    }\n\n    // Stable ID for this component instance\n    const componentIdRef = useRef<string>('');\n    if (!componentIdRef.current) {\n        const name = componentName || 'Component';\n        componentIdRef.current = generateComponentId(name);\n\n        // Register component in hierarchy\n        globalRenderTracker.registerComponent(name, componentIdRef.current);\n    }\n\n    const lastProps = useRef<TProps | null>(null);\n    const changesRef = useRef<Change[]>([]);\n    const renderCount = useRef(0);\n    const name = componentName || 'Component';\n    const strategy = options?.compareStrategy || 'shallow';\n\n    // Start performance tracking\n    globalPerformanceMonitor.markRenderStart(name, componentIdRef.current);\n\n    // Calculate changes during render\n    if (lastProps.current) {\n        changesRef.current = getChanges(\n            lastProps.current,\n            props,\n            strategy,\n            options?.customCompare,\n            options?.skipKeys\n        );\n\n        // Track render with changes\n        globalRenderTracker.trackRender(\n            name,\n            componentIdRef.current,\n            props,\n            changesRef.current\n        );\n\n        if (changesRef.current.length > 0) {\n            const msg = `[why-render] ${name} re-rendered because: ${changesRef.current.map(c => c.key).join(', ')}`;\n            console.warn(msg);\n\n            if (options?.verbose) {\n                console.groupCollapsed(`[why-render] ${name} details`);\n                changesRef.current.forEach(change => {\n                    // Truncate long values for display\n                    const formatVal = (v: any) => {\n                        try {\n                            const s = typeof v === 'string' ? v : JSON.stringify(v);\n                            return s && s.length > 1000 ? s.slice(0, 1000) + '...' : s;\n                        } catch { return String(v); }\n                    };\n\n                    console.log(`Prop '${change.key}':`, {\n                        ...change,\n                        oldValue: formatVal(change.oldValue),\n                        newValue: formatVal(change.newValue)\n                    });\n\n                    if (change.reason === 'function') {\n                        console.log('ðŸ’¡ Tip: Wrap with useCallback');\n                    } else if (change.reason === 'reference') {\n                        console.log('ðŸ’¡ Tip: Memoize object/array or move outside component');\n                    }\n                });\n                console.groupEnd();\n            }\n        }\n    } else {\n        // Initial render\n        globalRenderTracker.trackRender(\n            name,\n            componentIdRef.current,\n            props,\n            []\n        );\n    }\n\n    renderCount.current++;\n\n    // Commit phase: update lastProps and end performance tracking\n    useEffect(() => {\n        lastProps.current = props;\n        globalRenderTracker.commitRender(name, componentIdRef.current);\n    });\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            globalRenderTracker.unregisterComponent(componentIdRef.current);\n        };\n    }, []);\n\n    return {\n        lastProps: lastProps.current,\n        changes: changesRef.current,\n        componentId: componentIdRef.current,\n    };\n}\n\n// Static track method for opt-in tracking\n(useWhyRender as any).track = () => {\n    return Symbol('why-render-token');\n};\n","import { Change, CompareStrategy } from '../types';\n\nfunction isObject(x: any): x is object {\n    return typeof x === 'object' && x !== null;\n}\n\nfunction fastDeepEqual(a: any, b: any, depth: number = 3): boolean {\n    if (depth < 0) return true; // Stop recursion, assume equal to avoid perf hit\n    if (Object.is(a, b)) return true;\n\n    if (!isObject(a) || !isObject(b)) return false;\n    if (Array.isArray(a) !== Array.isArray(b)) return false;\n\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) return false;\n\n    for (const key of keysA) {\n        if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n        if (!fastDeepEqual((a as any)[key], (b as any)[key], depth - 1)) return false;\n    }\n\n    return true;\n}\n\nfunction deepEqual(a: any, b: any): boolean {\n    // Try structuredClone for deep copy comparison if available (modern browsers/Node)\n    // But structuredClone copies, it doesn't compare.\n    // We can use a recursive comparator that handles cycles if needed, \n    // or just JSON.stringify if we assume no cycles/functions for \"deep\" data.\n    // Requirement says: \"use user-provided structuredClone + JSON compare or a controlled recursive comparator\"\n    try {\n        return JSON.stringify(a) === JSON.stringify(b);\n    } catch (e) {\n        // Fallback to fastDeepEqual with higher depth if JSON fails (e.g. circular)\n        return fastDeepEqual(a, b, 10);\n    }\n}\n\nexport function getChanges(\n    prevProps: any,\n    nextProps: any,\n    strategy: CompareStrategy,\n    customCompare?: (a: any, b: any) => boolean,\n    skipKeys: string[] = []\n): Change[] {\n    const changes: Change[] = [];\n    const allKeys = new Set([...Object.keys(prevProps || {}), ...Object.keys(nextProps || {})]);\n\n    for (const key of allKeys) {\n        if (skipKeys.includes(key)) continue;\n\n        const prev = prevProps ? prevProps[key] : undefined;\n        const next = nextProps ? nextProps[key] : undefined;\n\n        if (Object.is(prev, next)) {\n            continue;\n        }\n\n        if (customCompare && customCompare(prev, next)) {\n            continue;\n        }\n\n        let reason: Change['reason'] = 'value';\n        let areDeepEqual = false;\n\n        if (typeof prev !== typeof next) {\n            reason = 'type';\n        } else if (typeof prev === 'function') {\n            reason = 'function';\n        } else if (Array.isArray(prev) && Array.isArray(next) && prev.length !== next.length) {\n            reason = 'length';\n        } else if (isObject(prev) && isObject(next)) {\n            // It's an object/array reference change\n            if (strategy === 'deep') {\n                areDeepEqual = deepEqual(prev, next);\n            } else if (strategy === 'fast-deep') {\n                areDeepEqual = fastDeepEqual(prev, next);\n            } else {\n                // shallow strategy: we already know they are not Object.is, so they are different refs\n                areDeepEqual = false;\n            }\n\n            if (areDeepEqual) {\n                reason = 'reference';\n            } else {\n                reason = 'value'; // Deeply different\n            }\n        }\n\n        changes.push({\n            key,\n            reason,\n            oldValue: prev,\n            newValue: next,\n        });\n    }\n\n    return changes;\n}\n","export function shouldInstrument(): boolean {\n    if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n        return true;\n    }\n    if (typeof window !== 'undefined' && (window as any).__WHY_RENDER__ === true) {\n        return true;\n    }\n    return false;\n}\n","/**\n * Simple type-safe event emitter for render tracking events\n */\n\nexport type RenderEventType =\n    | 'render:start'\n    | 'render:end'\n    | 'change:detected'\n    | 'performance:warning'\n    | 'component:mounted'\n    | 'component:unmounted';\n\nexport interface RenderEventPayload {\n    'render:start': {\n        componentName: string;\n        componentId: string;\n        timestamp: number;\n    };\n    'render:end': {\n        componentName: string;\n        componentId: string;\n        timestamp: number;\n        duration: number;\n    };\n    'change:detected': {\n        componentName: string;\n        componentId: string;\n        changes: Array<{\n            key: string;\n            reason: string;\n            oldValue: any;\n            newValue: any;\n        }>;\n    };\n    'performance:warning': {\n        componentName: string;\n        componentId: string;\n        duration: number;\n        threshold: number;\n    };\n    'component:mounted': {\n        componentName: string;\n        componentId: string;\n    };\n    'component:unmounted': {\n        componentName: string;\n        componentId: string;\n    };\n}\n\ntype EventHandler<T extends RenderEventType> = (payload: RenderEventPayload[T]) => void;\n\nexport class EventEmitter {\n    private listeners: Map<RenderEventType, Set<EventHandler<any>>> = new Map();\n\n    /**\n     * Subscribe to an event\n     */\n    on<T extends RenderEventType>(event: T, handler: EventHandler<T>): () => void {\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, new Set());\n        }\n\n        this.listeners.get(event)!.add(handler);\n\n        // Return unsubscribe function\n        return () => this.off(event, handler);\n    }\n\n    /**\n     * Unsubscribe from an event\n     */\n    off<T extends RenderEventType>(event: T, handler: EventHandler<T>): void {\n        const handlers = this.listeners.get(event);\n        if (handlers) {\n            handlers.delete(handler);\n        }\n    }\n\n    /**\n     * Emit an event to all subscribers\n     */\n    emit<T extends RenderEventType>(event: T, payload: RenderEventPayload[T]): void {\n        const handlers = this.listeners.get(event);\n        if (handlers) {\n            handlers.forEach(handler => {\n                try {\n                    handler(payload);\n                } catch (error) {\n                    console.error(`[why-render] Error in event handler for ${event}:`, error);\n                }\n            });\n        }\n    }\n\n    /**\n     * Subscribe to an event once (auto-unsubscribe after first call)\n     */\n    once<T extends RenderEventType>(event: T, handler: EventHandler<T>): () => void {\n        const wrappedHandler = (payload: RenderEventPayload[T]) => {\n            handler(payload);\n            this.off(event, wrappedHandler);\n        };\n\n        return this.on(event, wrappedHandler as EventHandler<T>);\n    }\n\n    /**\n     * Remove all listeners for a specific event or all events\n     */\n    clear(event?: RenderEventType): void {\n        if (event) {\n            this.listeners.delete(event);\n        } else {\n            this.listeners.clear();\n        }\n    }\n\n    /**\n     * Get listener count for an event\n     */\n    listenerCount(event: RenderEventType): number {\n        return this.listeners.get(event)?.size ?? 0;\n    }\n}\n\n// Global singleton instance\nexport const globalEventEmitter = new EventEmitter();\n","/**\n * Performance monitoring for React components\n * Tracks render duration, detects slow renders, monitors transitions\n */\n\nimport { globalEventEmitter } from './EventEmitter';\n\nexport interface PerformanceMetrics {\n    componentName: string;\n    componentId: string;\n    renderCount: number;\n    totalTime: number;\n    averageTime: number;\n    lastRenderTime: number;\n    slowRenders: number;\n    maxRenderTime: number;\n    minRenderTime: number;\n}\n\nexport interface PerformanceOptions {\n    slowThresholdMs?: number;\n    enableMarks?: boolean;\n}\n\nconst DEFAULT_SLOW_THRESHOLD = 16; // 16ms (one frame at 60fps)\n\nexport class PerformanceMonitor {\n    private metrics: Map<string, PerformanceMetrics> = new Map();\n    private activeRenders: Map<string, number> = new Map();\n    private options: Required<PerformanceOptions>;\n\n    constructor(options: PerformanceOptions = {}) {\n        this.options = {\n            slowThresholdMs: options.slowThresholdMs ?? DEFAULT_SLOW_THRESHOLD,\n            enableMarks: options.enableMarks ?? false,\n        };\n    }\n\n    /**\n     * Mark the start of a component render\n     */\n    markRenderStart(componentName: string, componentId: string): void {\n        const timestamp = performance.now();\n        this.activeRenders.set(componentId, timestamp);\n\n        if (this.options.enableMarks) {\n            performance.mark(`${componentName}:${componentId}:start`);\n        }\n\n        globalEventEmitter.emit('render:start', {\n            componentName,\n            componentId,\n            timestamp,\n        });\n    }\n\n    /**\n     * Mark the end of a component render and record metrics\n     */\n    markRenderEnd(componentName: string, componentId: string): number {\n        const endTime = performance.now();\n        const startTime = this.activeRenders.get(componentId);\n\n        if (!startTime) {\n            console.warn(`[why-render] No start time found for ${componentName}:${componentId}`);\n            return 0;\n        }\n\n        const duration = endTime - startTime;\n        this.activeRenders.delete(componentId);\n\n        if (this.options.enableMarks) {\n            const markName = `${componentName}:${componentId}`;\n            performance.mark(`${markName}:end`);\n            performance.measure(markName, `${markName}:start`, `${markName}:end`);\n        }\n\n        // Update metrics\n        this.updateMetrics(componentName, componentId, duration);\n\n        // Emit event\n        globalEventEmitter.emit('render:end', {\n            componentName,\n            componentId,\n            timestamp: endTime,\n            duration,\n        });\n\n        // Check for slow render\n        if (duration > this.options.slowThresholdMs) {\n            globalEventEmitter.emit('performance:warning', {\n                componentName,\n                componentId,\n                duration,\n                threshold: this.options.slowThresholdMs,\n            });\n        }\n\n        return duration;\n    }\n\n    /**\n     * Update performance metrics for a component\n     */\n    private updateMetrics(componentName: string, componentId: string, duration: number): void {\n        const existing = this.metrics.get(componentId);\n\n        if (existing) {\n            const newRenderCount = existing.renderCount + 1;\n            const newTotalTime = existing.totalTime + duration;\n\n            this.metrics.set(componentId, {\n                componentName,\n                componentId,\n                renderCount: newRenderCount,\n                totalTime: newTotalTime,\n                averageTime: newTotalTime / newRenderCount,\n                lastRenderTime: duration,\n                slowRenders: duration > this.options.slowThresholdMs\n                    ? existing.slowRenders + 1\n                    : existing.slowRenders,\n                maxRenderTime: Math.max(existing.maxRenderTime, duration),\n                minRenderTime: Math.min(existing.minRenderTime, duration),\n            });\n        } else {\n            this.metrics.set(componentId, {\n                componentName,\n                componentId,\n                renderCount: 1,\n                totalTime: duration,\n                averageTime: duration,\n                lastRenderTime: duration,\n                slowRenders: duration > this.options.slowThresholdMs ? 1 : 0,\n                maxRenderTime: duration,\n                minRenderTime: duration,\n            });\n        }\n    }\n\n    /**\n     * Get metrics for a specific component\n     */\n    getMetrics(componentId: string): PerformanceMetrics | undefined {\n        return this.metrics.get(componentId);\n    }\n\n    /**\n     * Get all metrics\n     */\n    getAllMetrics(): PerformanceMetrics[] {\n        return Array.from(this.metrics.values());\n    }\n\n    /**\n     * Get components sorted by total render time\n     */\n    getSlowestComponents(limit: number = 10): PerformanceMetrics[] {\n        return Array.from(this.metrics.values())\n            .sort((a, b) => b.totalTime - a.totalTime)\n            .slice(0, limit);\n    }\n\n    /**\n     * Get components with most renders\n     */\n    getMostRenderedComponents(limit: number = 10): PerformanceMetrics[] {\n        return Array.from(this.metrics.values())\n            .sort((a, b) => b.renderCount - a.renderCount)\n            .slice(0, limit);\n    }\n\n    /**\n     * Clear metrics for a component or all components\n     */\n    clearMetrics(componentId?: string): void {\n        if (componentId) {\n            this.metrics.delete(componentId);\n        } else {\n            this.metrics.clear();\n        }\n    }\n\n    /**\n     * Update slow threshold\n     */\n    setSlowThreshold(thresholdMs: number): void {\n        this.options.slowThresholdMs = thresholdMs;\n    }\n}\n\n// Global singleton instance\nexport const globalPerformanceMonitor = new PerformanceMonitor();\n","/**\n * Core render tracking engine\n * Tracks component renders, prop changes, and maintains render history\n */\n\nimport { globalEventEmitter } from './EventEmitter';\nimport { globalPerformanceMonitor } from './PerformanceMonitor';\nimport type { Change } from '../types';\n\nexport interface RenderEvent {\n    id: string;\n    componentName: string;\n    componentId: string;\n    timestamp: number;\n    duration: number;\n    changes: Change[];\n    props: any;\n    renderCount: number;\n}\n\nexport interface ComponentHierarchyNode {\n    componentName: string;\n    componentId: string;\n    children: ComponentHierarchyNode[];\n    parent?: ComponentHierarchyNode;\n    depth: number;\n}\n\nexport class RenderTracker {\n    private renderHistory: Map<string, RenderEvent> = new Map();\n    private componentHierarchy: Map<string, ComponentHierarchyNode> = new Map();\n    private componentRenderCounts: Map<string, number> = new Map();\n    private maxHistorySize: number;\n\n    constructor(maxHistorySize: number = 1000) {\n        this.maxHistorySize = maxHistorySize;\n    }\n\n    /**\n     * Track a component render\n     */\n    trackRender(\n        componentName: string,\n        componentId: string,\n        props: any,\n        changes: Change[]\n    ): void {\n        const timestamp = performance.now();\n\n        // Start performance monitoring\n        globalPerformanceMonitor.markRenderStart(componentName, componentId);\n\n        // Update render count\n        const renderCount = (this.componentRenderCounts.get(componentId) ?? 0) + 1;\n        this.componentRenderCounts.set(componentId, renderCount);\n\n        // Emit changes if any\n        if (changes.length > 0) {\n            globalEventEmitter.emit('change:detected', {\n                componentName,\n                componentId,\n                changes,\n            });\n        }\n\n        // Record render event (will be completed in commitRender)\n        const eventId = `${componentId}-${timestamp}`;\n        this.renderHistory.set(eventId, {\n            id: eventId,\n            componentName,\n            componentId,\n            timestamp,\n            duration: 0, // Will be set in commitRender\n            changes,\n            props,\n            renderCount,\n        });\n\n        // Maintain history size\n        if (this.renderHistory.size > this.maxHistorySize) {\n            const firstKey = this.renderHistory.keys().next().value;\n            if (firstKey) {\n                this.renderHistory.delete(firstKey);\n            }\n        }\n    }\n\n    /**\n     * Commit a render (called after render completes)\n     */\n    commitRender(componentName: string, componentId: string): void {\n        const duration = globalPerformanceMonitor.markRenderEnd(componentName, componentId);\n\n        // Update the most recent render event with duration\n        const recentEvent = Array.from(this.renderHistory.values())\n            .reverse()\n            .find(event => event.componentId === componentId);\n\n        if (recentEvent) {\n            recentEvent.duration = duration;\n        }\n    }\n\n    /**\n     * Register a component in the hierarchy\n     */\n    registerComponent(\n        componentName: string,\n        componentId: string,\n        parentId?: string\n    ): void {\n        const parent = parentId ? this.componentHierarchy.get(parentId) : undefined;\n        const depth = parent ? parent.depth + 1 : 0;\n\n        const node: ComponentHierarchyNode = {\n            componentName,\n            componentId,\n            children: [],\n            parent,\n            depth,\n        };\n\n        this.componentHierarchy.set(componentId, node);\n\n        if (parent) {\n            parent.children.push(node);\n        }\n\n        globalEventEmitter.emit('component:mounted', {\n            componentName,\n            componentId,\n        });\n    }\n\n    /**\n     * Unregister a component from the hierarchy\n     */\n    unregisterComponent(componentId: string): void {\n        const node = this.componentHierarchy.get(componentId);\n\n        if (node) {\n            // Remove from parent's children\n            if (node.parent) {\n                node.parent.children = node.parent.children.filter(\n                    child => child.componentId !== componentId\n                );\n            }\n\n            this.componentHierarchy.delete(componentId);\n\n            globalEventEmitter.emit('component:unmounted', {\n                componentName: node.componentName,\n                componentId,\n            });\n        }\n    }\n\n    /**\n     * Get render history for a component\n     */\n    getComponentHistory(componentId: string): RenderEvent[] {\n        return Array.from(this.renderHistory.values())\n            .filter(event => event.componentId === componentId)\n            .sort((a, b) => a.timestamp - b.timestamp);\n    }\n\n    /**\n     * Get all render history\n     */\n    getAllHistory(): RenderEvent[] {\n        return Array.from(this.renderHistory.values())\n            .sort((a, b) => a.timestamp - b.timestamp);\n    }\n\n    /**\n     * Get recent renders (last N)\n     */\n    getRecentRenders(limit: number = 50): RenderEvent[] {\n        return Array.from(this.renderHistory.values())\n            .sort((a, b) => b.timestamp - a.timestamp)\n            .slice(0, limit);\n    }\n\n    /**\n     * Get component hierarchy tree\n     */\n    getHierarchy(): ComponentHierarchyNode[] {\n        return Array.from(this.componentHierarchy.values())\n            .filter(node => !node.parent);\n    }\n\n    /**\n     * Get a specific component node\n     */\n    getComponentNode(componentId: string): ComponentHierarchyNode | undefined {\n        return this.componentHierarchy.get(componentId);\n    }\n\n    /**\n     * Get render count for a component\n     */\n    getRenderCount(componentId: string): number {\n        return this.componentRenderCounts.get(componentId) ?? 0;\n    }\n\n    /**\n     * Clear all tracking data\n     */\n    clear(): void {\n        this.renderHistory.clear();\n        this.componentHierarchy.clear();\n        this.componentRenderCounts.clear();\n        globalPerformanceMonitor.clearMetrics();\n    }\n\n    /**\n     * Export data for debugging/reports\n     */\n    export(): {\n        history: RenderEvent[];\n        hierarchy: ComponentHierarchyNode[];\n        metrics: ReturnType<typeof globalPerformanceMonitor.getAllMetrics>;\n    } {\n        return {\n            history: this.getAllHistory(),\n            hierarchy: this.getHierarchy(),\n            metrics: globalPerformanceMonitor.getAllMetrics(),\n        };\n    }\n}\n\n// Global singleton instance\nexport const globalRenderTracker = new RenderTracker();\n","import React, { forwardRef } from 'react';\nimport { Options } from '../types';\nimport { useWhyRender } from '../hooks/useWhyRender';\n\nexport function withWhyRender<TProps extends object>(\n    Component: React.ComponentType<TProps>,\n    options?: Options\n): React.FC<TProps> {\n    const WrappedComponent = forwardRef<any, TProps>((props, ref) => {\n        const componentName = Component.displayName || Component.name || 'Component';\n        useWhyRender(props, componentName, options);\n\n        return <Component {...props as any} ref={ref} />;\n    });\n\n    WrappedComponent.displayName = `withWhyRender(${Component.displayName || Component.name || 'Component'})`;\n    return WrappedComponent as unknown as React.FC<TProps>;\n}\n","import { useWhyRender } from './hooks/useWhyRender';\nimport { withWhyRender } from './hoc/withWhyRender';\nimport { Options, CompareStrategy, Change } from './types';\n\n// Augment the function type to include track\nexport type UseWhyRender = typeof useWhyRender & { track: () => symbol };\n\nconst useWhyRenderExport = useWhyRender as UseWhyRender;\n\nexport { useWhyRenderExport as useWhyRender };\nexport { withWhyRender };\nexport type { Options, CompareStrategy, Change };\n"],"mappings":"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","names":["name"]}