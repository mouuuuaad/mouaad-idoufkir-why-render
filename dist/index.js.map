{"version":3,"sources":["../src/hooks/useWhyRender.ts","../src/utils/diff.ts","../src/utils/env.ts","../src/hoc/withWhyRender.tsx","../src/index.ts"],"sourcesContent":["import { useRef, useEffect } from 'react';\nimport { Options, Change } from '../types';\nimport { getChanges } from '../utils/diff';\nimport { shouldInstrument } from '../utils/env';\nimport { globalRenderTracker } from '../engine/RenderTracker';\nimport { globalPerformanceMonitor } from '../engine/PerformanceMonitor';\n\n// Generate stable component IDs\nlet componentIdCounter = 0;\nconst generateComponentId = (name: string): string => {\n    return `${name}-${++componentIdCounter}-${Date.now()}`;\n};\n\nexport function useWhyRender<TProps = any>(\n    props: TProps,\n    componentName?: string,\n    options?: Options\n): { lastProps: TProps | null; changes: Change[]; componentId: string } {\n    if (!shouldInstrument()) {\n        return { lastProps: null, changes: [], componentId: '' };\n    }\n\n    // Stable ID for this component instance\n    const componentIdRef = useRef<string>('');\n    if (!componentIdRef.current) {\n        const name = componentName || 'Component';\n        componentIdRef.current = generateComponentId(name);\n\n        // Register component in hierarchy\n        globalRenderTracker.registerComponent(name, componentIdRef.current);\n    }\n\n    const lastProps = useRef<TProps | null>(null);\n    const changesRef = useRef<Change[]>([]);\n    const renderCount = useRef(0);\n    const name = componentName || 'Component';\n    const strategy = options?.compareStrategy || 'shallow';\n\n    // Start performance tracking\n    globalPerformanceMonitor.markRenderStart(name, componentIdRef.current);\n\n    // Calculate changes during render\n    if (lastProps.current) {\n        changesRef.current = getChanges(\n            lastProps.current,\n            props,\n            strategy,\n            options?.customCompare,\n            options?.skipKeys\n        );\n\n        // Track render with changes\n        globalRenderTracker.trackRender(\n            name,\n            componentIdRef.current,\n            props,\n            changesRef.current\n        );\n\n        if (changesRef.current.length > 0) {\n            const msg = `[why-render] ${name} re-rendered because: ${changesRef.current.map(c => c.key).join(', ')}`;\n            console.warn(msg);\n\n            if (options?.verbose) {\n                console.groupCollapsed(`[why-render] ${name} details`);\n                changesRef.current.forEach(change => {\n                    // Truncate long values for display\n                    const formatVal = (v: any) => {\n                        try {\n                            const s = typeof v === 'string' ? v : JSON.stringify(v);\n                            return s && s.length > 1000 ? s.slice(0, 1000) + '...' : s;\n                        } catch { return String(v); }\n                    };\n\n                    console.log(`Prop '${change.key}':`, {\n                        ...change,\n                        oldValue: formatVal(change.oldValue),\n                        newValue: formatVal(change.newValue)\n                    });\n\n                    if (change.reason === 'function') {\n                        console.log('ðŸ’¡ Tip: Wrap with useCallback');\n                    } else if (change.reason === 'reference') {\n                        console.log('ðŸ’¡ Tip: Memoize object/array or move outside component');\n                    }\n                });\n                console.groupEnd();\n            }\n        }\n    } else {\n        // Initial render\n        globalRenderTracker.trackRender(\n            name,\n            componentIdRef.current,\n            props,\n            []\n        );\n    }\n\n    renderCount.current++;\n\n    // Commit phase: update lastProps and end performance tracking\n    useEffect(() => {\n        lastProps.current = props;\n        globalRenderTracker.commitRender(name, componentIdRef.current);\n    });\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            globalRenderTracker.unregisterComponent(componentIdRef.current);\n        };\n    }, []);\n\n    return {\n        lastProps: lastProps.current,\n        changes: changesRef.current,\n        componentId: componentIdRef.current,\n    };\n}\n\n// Static track method for opt-in tracking\n(useWhyRender as any).track = () => {\n    return Symbol('why-render-token');\n};\n","import { Change, CompareStrategy } from '../types';\n\nfunction isObject(x: any): x is object {\n    return typeof x === 'object' && x !== null;\n}\n\nfunction fastDeepEqual(a: any, b: any, depth: number = 3): boolean {\n    if (depth < 0) return true; // Stop recursion, assume equal to avoid perf hit\n    if (Object.is(a, b)) return true;\n\n    if (!isObject(a) || !isObject(b)) return false;\n    if (Array.isArray(a) !== Array.isArray(b)) return false;\n\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) return false;\n\n    for (const key of keysA) {\n        if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n        if (!fastDeepEqual((a as any)[key], (b as any)[key], depth - 1)) return false;\n    }\n\n    return true;\n}\n\nfunction deepEqual(a: any, b: any): boolean {\n    // Try structuredClone for deep copy comparison if available (modern browsers/Node)\n    // But structuredClone copies, it doesn't compare.\n    // We can use a recursive comparator that handles cycles if needed, \n    // or just JSON.stringify if we assume no cycles/functions for \"deep\" data.\n    // Requirement says: \"use user-provided structuredClone + JSON compare or a controlled recursive comparator\"\n    try {\n        return JSON.stringify(a) === JSON.stringify(b);\n    } catch (e) {\n        // Fallback to fastDeepEqual with higher depth if JSON fails (e.g. circular)\n        return fastDeepEqual(a, b, 10);\n    }\n}\n\nexport function getChanges(\n    prevProps: any,\n    nextProps: any,\n    strategy: CompareStrategy,\n    customCompare?: (a: any, b: any) => boolean,\n    skipKeys: string[] = []\n): Change[] {\n    const changes: Change[] = [];\n    const allKeys = new Set([...Object.keys(prevProps || {}), ...Object.keys(nextProps || {})]);\n\n    for (const key of allKeys) {\n        if (skipKeys.includes(key)) continue;\n\n        const prev = prevProps ? prevProps[key] : undefined;\n        const next = nextProps ? nextProps[key] : undefined;\n\n        if (Object.is(prev, next)) {\n            continue;\n        }\n\n        if (customCompare && customCompare(prev, next)) {\n            continue;\n        }\n\n        let reason: Change['reason'] = 'value';\n        let areDeepEqual = false;\n\n        if (typeof prev !== typeof next) {\n            reason = 'type';\n        } else if (typeof prev === 'function') {\n            reason = 'function';\n        } else if (Array.isArray(prev) && Array.isArray(next) && prev.length !== next.length) {\n            reason = 'length';\n        } else if (isObject(prev) && isObject(next)) {\n            // It's an object/array reference change\n            if (strategy === 'deep') {\n                areDeepEqual = deepEqual(prev, next);\n            } else if (strategy === 'fast-deep') {\n                areDeepEqual = fastDeepEqual(prev, next);\n            } else {\n                // shallow strategy: we already know they are not Object.is, so they are different refs\n                areDeepEqual = false;\n            }\n\n            if (areDeepEqual) {\n                reason = 'reference';\n            } else {\n                reason = 'value'; // Deeply different\n            }\n        }\n\n        changes.push({\n            key,\n            reason,\n            oldValue: prev,\n            newValue: next,\n        });\n    }\n\n    return changes;\n}\n","export function shouldInstrument(): boolean {\n    // Check Vite environment variable (import.meta.env)\n    if (typeof import.meta !== 'undefined' && import.meta.env && import.meta.env.DEV) {\n        return true;\n    }\n    // Check Node.js environment variable (process.env)\n    if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n        return true;\n    }\n    // Check manual override flag\n    if (typeof window !== 'undefined' && (window as any).__WHY_RENDER__ === true) {\n        return true;\n    }\n    return false;\n}\n","import React, { forwardRef } from 'react';\nimport { Options } from '../types';\nimport { useWhyRender } from '../hooks/useWhyRender';\n\nexport function withWhyRender<TProps extends object>(\n    Component: React.ComponentType<TProps>,\n    options?: Options\n): React.FC<TProps> {\n    const WrappedComponent = forwardRef<any, TProps>((props, ref) => {\n        const componentName = Component.displayName || Component.name || 'Component';\n        useWhyRender(props, componentName, options);\n\n        return <Component {...props as any} ref={ref} />;\n    });\n\n    WrappedComponent.displayName = `withWhyRender(${Component.displayName || Component.name || 'Component'})`;\n    return WrappedComponent as unknown as React.FC<TProps>;\n}\n","import { useWhyRender } from './hooks/useWhyRender';\nimport { withWhyRender } from './hoc/withWhyRender';\nimport { Options, CompareStrategy, Change } from './types';\n\n// Augment the function type to include track\nexport type UseWhyRender = typeof useWhyRender & { track: () => symbol };\n\nconst useWhyRenderExport = useWhyRender as UseWhyRender;\n\nexport { useWhyRenderExport as useWhyRender };\nexport { withWhyRender };\nexport type { Options, CompareStrategy, Change };\n"],"mappings":"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","names":["name"]}