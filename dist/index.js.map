{"version":3,"sources":["../src/utils/diff.ts","../src/utils/env.ts","../src/hooks/useWhyRender.ts","../src/hoc/withWhyRender.tsx"],"names":["useRef","useEffect","forwardRef","jsx"],"mappings":"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","file":"index.js","sourcesContent":["import { Change, CompareStrategy } from '../types';\n\nexport function getChanges(\n    prevProps: any,\n    nextProps: any,\n    strategy: CompareStrategy,\n    customCompare?: (a: any, b: any) => boolean\n): Change[] {\n    const changes: Change[] = [];\n    const allKeys = new Set([...Object.keys(prevProps || {}), ...Object.keys(nextProps || {})]);\n\n    for (const key of allKeys) {\n        const prev = prevProps ? prevProps[key] : undefined;\n        const next = nextProps ? nextProps[key] : undefined;\n\n        if (Object.is(prev, next)) {\n            continue;\n        }\n\n        if (customCompare && customCompare(prev, next)) {\n            continue;\n        }\n\n        let reason: Change['reason'] = 'value';\n\n        if (typeof prev !== typeof next) {\n            reason = 'type';\n        } else if (typeof prev === 'function') {\n            reason = 'function';\n        } else if (Array.isArray(prev) && Array.isArray(next) && prev.length !== next.length) {\n            reason = 'length';\n        } else if (typeof prev === 'object' && prev !== null && next !== null) {\n            // It's an object/array reference change\n            if (strategy === 'deep' || strategy === 'fast-deep') {\n                // simplified deep check for demonstration, real deep check would be recursive\n                // For \"fast-deep\", maybe just JSON.stringify or shallow check of keys\n                if (JSON.stringify(prev) === JSON.stringify(next)) {\n                    reason = 'reference'; // Content is same, ref is different\n                } else {\n                    reason = 'value'; // Content is different\n                }\n            } else {\n                reason = 'reference'; // Default assumption for objects if not equal by reference\n            }\n        }\n\n        changes.push({\n            key,\n            reason,\n            oldValue: prev,\n            newValue: next,\n        });\n    }\n\n    return changes;\n}\n","export function shouldInstrument(): boolean {\n    if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n        return true;\n    }\n    if (typeof window !== 'undefined' && (window as any).__WHY_RENDER__ === true) {\n        return true;\n    }\n    return false;\n}\n","import { useRef, useEffect } from 'react';\nimport { Options, Change } from '../types';\nimport { getChanges } from '../utils/diff';\nimport { shouldInstrument } from '../utils/env';\n\nexport function useWhyRender<TProps = any>(\n    props: TProps,\n    componentName?: string,\n    options?: Options\n): { lastProps: TProps | null; changes: Change[] } {\n    if (!shouldInstrument()) {\n        return { lastProps: null, changes: [] };\n    }\n\n    const lastProps = useRef<TProps | null>(null);\n    const changesRef = useRef<Change[]>([]);\n\n    const name = componentName || 'Component';\n    const strategy = options?.compareStrategy || 'shallow';\n\n    // Calculate changes during render to capture the \"why\" immediately\n    if (lastProps.current) {\n        changesRef.current = getChanges(lastProps.current, props, strategy, options?.customCompare);\n\n        if (changesRef.current.length > 0) {\n            // Log immediately or schedule? \n            // Requirement: \"succinct single-line console.warn per re-render\"\n            // We do this in render to be accurate to the render phase, but console.log during render is sometimes discouraged.\n            // However, for debugging tools, it's often necessary.\n\n            const msg = `[why-render] ${name} re-rendered because: ${changesRef.current.map(c => c.key).join(', ')}`;\n            console.warn(msg);\n\n            if (options?.verbose) {\n                console.groupCollapsed(`[why-render] ${name} details`);\n                changesRef.current.forEach(change => {\n                    console.log(`Prop '${change.key}':`, change);\n                    if (change.reason === 'function') {\n                        console.log('Tip: Wrap with useCallback');\n                    } else if (change.reason === 'reference') {\n                        console.log('Tip: Memoize object/array or move outside component');\n                    }\n                });\n                console.groupEnd();\n            }\n        }\n    }\n\n    // Update ref for next render\n    // We use useEffect to update the ref AFTER the render is committed, \n    // so that if the render is aborted (Concurrent mode), we don't update the ref prematurely.\n    // BUT, if we want to compare against the *previous committed* props, we should update it in useEffect.\n    // If we update in render, we might compare against a render that was thrown away.\n    // Correct pattern for \"previous props\" tracking in concurrent mode is usually a ref updated in useEffect.\n\n    useEffect(() => {\n        lastProps.current = props;\n    });\n\n    return {\n        lastProps: lastProps.current,\n        changes: changesRef.current\n    };\n}\n","import React, { forwardRef } from 'react';\nimport { Options } from '../types';\nimport { useWhyRender } from '../hooks/useWhyRender';\n\nexport function withWhyRender<TProps extends object>(\n    Component: React.ComponentType<TProps>,\n    options?: Options\n): React.FC<TProps> {\n    const WrappedComponent = forwardRef<any, TProps>((props, ref) => {\n        const componentName = Component.displayName || Component.name || 'Component';\n        useWhyRender(props, componentName, options);\n\n        return <Component {...props as any} ref={ref} />;\n    });\n\n    WrappedComponent.displayName = `withWhyRender(${Component.displayName || Component.name || 'Component'})`;\n    return WrappedComponent as unknown as React.FC<TProps>;\n}\n"]}