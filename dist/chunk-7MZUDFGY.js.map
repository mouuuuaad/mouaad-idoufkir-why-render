{"version":3,"sources":["../src/engine/PerformanceMonitor.ts","../src/engine/RenderTracker.ts"],"sourcesContent":["/**\n * Performance monitoring for React components\n * Tracks render duration, detects slow renders, monitors transitions\n */\n\nimport { globalEventEmitter } from './EventEmitter';\n\nexport interface PerformanceMetrics {\n    componentName: string;\n    componentId: string;\n    renderCount: number;\n    totalTime: number;\n    averageTime: number;\n    lastRenderTime: number;\n    slowRenders: number;\n    maxRenderTime: number;\n    minRenderTime: number;\n}\n\nexport interface PerformanceOptions {\n    slowThresholdMs?: number;\n    enableMarks?: boolean;\n}\n\nconst DEFAULT_SLOW_THRESHOLD = 16; // 16ms (one frame at 60fps)\n\nexport class PerformanceMonitor {\n    private metrics: Map<string, PerformanceMetrics> = new Map();\n    private activeRenders: Map<string, number> = new Map();\n    private options: Required<PerformanceOptions>;\n\n    constructor(options: PerformanceOptions = {}) {\n        this.options = {\n            slowThresholdMs: options.slowThresholdMs ?? DEFAULT_SLOW_THRESHOLD,\n            enableMarks: options.enableMarks ?? false,\n        };\n    }\n\n    /**\n     * Mark the start of a component render\n     */\n    markRenderStart(componentName: string, componentId: string): void {\n        const timestamp = performance.now();\n        this.activeRenders.set(componentId, timestamp);\n\n        if (this.options.enableMarks) {\n            performance.mark(`${componentName}:${componentId}:start`);\n        }\n\n        globalEventEmitter.emit('render:start', {\n            componentName,\n            componentId,\n            timestamp,\n        });\n    }\n\n    /**\n     * Mark the end of a component render and record metrics\n     */\n    markRenderEnd(componentName: string, componentId: string): number {\n        const endTime = performance.now();\n        const startTime = this.activeRenders.get(componentId);\n\n        if (!startTime) {\n            console.warn(`[why-render] No start time found for ${componentName}:${componentId}`);\n            return 0;\n        }\n\n        const duration = endTime - startTime;\n        this.activeRenders.delete(componentId);\n\n        if (this.options.enableMarks) {\n            const markName = `${componentName}:${componentId}`;\n            performance.mark(`${markName}:end`);\n            performance.measure(markName, `${markName}:start`, `${markName}:end`);\n        }\n\n        // Update metrics\n        this.updateMetrics(componentName, componentId, duration);\n\n        // Check for slow render\n        if (duration > this.options.slowThresholdMs) {\n            globalEventEmitter.emit('performance:warning', {\n                componentName,\n                componentId,\n                duration,\n                threshold: this.options.slowThresholdMs,\n            });\n        }\n\n        return duration;\n    }\n\n    /**\n     * Update performance metrics for a component\n     */\n    private updateMetrics(componentName: string, componentId: string, duration: number): void {\n        const existing = this.metrics.get(componentId);\n\n        if (existing) {\n            const newRenderCount = existing.renderCount + 1;\n            const newTotalTime = existing.totalTime + duration;\n\n            this.metrics.set(componentId, {\n                componentName,\n                componentId,\n                renderCount: newRenderCount,\n                totalTime: newTotalTime,\n                averageTime: newTotalTime / newRenderCount,\n                lastRenderTime: duration,\n                slowRenders: duration > this.options.slowThresholdMs\n                    ? existing.slowRenders + 1\n                    : existing.slowRenders,\n                maxRenderTime: Math.max(existing.maxRenderTime, duration),\n                minRenderTime: Math.min(existing.minRenderTime, duration),\n            });\n        } else {\n            this.metrics.set(componentId, {\n                componentName,\n                componentId,\n                renderCount: 1,\n                totalTime: duration,\n                averageTime: duration,\n                lastRenderTime: duration,\n                slowRenders: duration > this.options.slowThresholdMs ? 1 : 0,\n                maxRenderTime: duration,\n                minRenderTime: duration,\n            });\n        }\n    }\n\n    /**\n     * Get metrics for a specific component\n     */\n    getMetrics(componentId: string): PerformanceMetrics | undefined {\n        return this.metrics.get(componentId);\n    }\n\n    /**\n     * Get all metrics\n     */\n    getAllMetrics(): PerformanceMetrics[] {\n        return Array.from(this.metrics.values());\n    }\n\n    /**\n     * Get components sorted by total render time\n     */\n    getSlowestComponents(limit: number = 10): PerformanceMetrics[] {\n        return Array.from(this.metrics.values())\n            .sort((a, b) => b.totalTime - a.totalTime)\n            .slice(0, limit);\n    }\n\n    /**\n     * Get components with most renders\n     */\n    getMostRenderedComponents(limit: number = 10): PerformanceMetrics[] {\n        return Array.from(this.metrics.values())\n            .sort((a, b) => b.renderCount - a.renderCount)\n            .slice(0, limit);\n    }\n\n    /**\n     * Clear metrics for a component or all components\n     */\n    clearMetrics(componentId?: string): void {\n        if (componentId) {\n            this.metrics.delete(componentId);\n        } else {\n            this.metrics.clear();\n        }\n    }\n\n    /**\n     * Update slow threshold\n     */\n    setSlowThreshold(thresholdMs: number): void {\n        this.options.slowThresholdMs = thresholdMs;\n    }\n}\n\n// Global singleton instance\nexport const globalPerformanceMonitor = new PerformanceMonitor();\n","/**\n * Core render tracking engine\n * Tracks component renders, prop changes, and maintains render history\n */\n\nimport { globalEventEmitter } from './EventEmitter';\nimport { globalPerformanceMonitor } from './PerformanceMonitor';\nimport type { Change, RenderEvent } from '../types';\n\nexport interface ComponentHierarchyNode {\n    componentName: string;\n    componentId: string;\n    children: ComponentHierarchyNode[];\n    parent?: ComponentHierarchyNode;\n    depth: number;\n}\n\nexport class RenderTracker {\n    private renderHistory: Map<string, RenderEvent> = new Map();\n    private componentHierarchy: Map<string, ComponentHierarchyNode> = new Map();\n    private componentRenderCounts: Map<string, number> = new Map();\n    private maxHistorySize: number;\n\n    constructor(maxHistorySize: number = 1000) {\n        this.maxHistorySize = maxHistorySize;\n    }\n\n    /**\n     * Track a component render\n     */\n    trackRender(\n        componentName: string,\n        componentId: string,\n        props: any,\n        changes: Change[]\n    ): void {\n        const timestamp = performance.now();\n\n        // Start performance monitoring\n        globalPerformanceMonitor.markRenderStart(componentName, componentId);\n\n        // Update render count\n        const renderCount = (this.componentRenderCounts.get(componentId) ?? 0) + 1;\n        this.componentRenderCounts.set(componentId, renderCount);\n\n        // Emit changes if any\n        if (changes.length > 0) {\n            globalEventEmitter.emit('change:detected', {\n                componentName,\n                componentId,\n                changes,\n            });\n        }\n\n        // Record render event (will be completed in commitRender)\n        const eventId = `${componentId}-${timestamp}`;\n        this.renderHistory.set(eventId, {\n            id: eventId,\n            componentName,\n            componentId,\n            timestamp,\n            duration: 0, // Will be set in commitRender\n            changes,\n            props,\n            renderCount,\n        });\n\n        // Maintain history size\n        if (this.renderHistory.size > this.maxHistorySize) {\n            const firstKey = this.renderHistory.keys().next().value;\n            if (firstKey) {\n                this.renderHistory.delete(firstKey);\n            }\n        }\n    }\n\n    /**\n     * Commit a render (called after render completes)\n     */\n    commitRender(componentName: string, componentId: string): void {\n        const duration = globalPerformanceMonitor.markRenderEnd(componentName, componentId);\n\n        // Update the most recent render event with duration\n        const recentEvent = Array.from(this.renderHistory.values())\n            .reverse()\n            .find(event => event.componentId === componentId);\n\n        if (recentEvent) {\n            recentEvent.duration = duration;\n\n            console.log('[RenderTracker] Emitting render:end event:', {\n                componentName,\n                componentId,\n                eventId: recentEvent.id,\n                duration: recentEvent.duration,\n            });\n            globalEventEmitter.emit('render:end', {\n                componentName,\n                componentId,\n                renderEvent: recentEvent,\n            });\n        }\n    }\n\n    /**\n     * Register a component in the hierarchy\n     */\n    registerComponent(\n        componentName: string,\n        componentId: string,\n        parentId?: string\n    ): void {\n        const parent = parentId ? this.componentHierarchy.get(parentId) : undefined;\n        const depth = parent ? parent.depth + 1 : 0;\n\n        const node: ComponentHierarchyNode = {\n            componentName,\n            componentId,\n            children: [],\n            parent,\n            depth,\n        };\n\n        this.componentHierarchy.set(componentId, node);\n\n        if (parent) {\n            parent.children.push(node);\n        }\n\n        globalEventEmitter.emit('component:mounted', {\n            componentName,\n            componentId,\n        });\n    }\n\n    /**\n     * Unregister a component from the hierarchy\n     */\n    unregisterComponent(componentId: string): void {\n        const node = this.componentHierarchy.get(componentId);\n\n        if (node) {\n            // Remove from parent's children\n            if (node.parent) {\n                node.parent.children = node.parent.children.filter(\n                    child => child.componentId !== componentId\n                );\n            }\n\n            this.componentHierarchy.delete(componentId);\n\n            globalEventEmitter.emit('component:unmounted', {\n                componentName: node.componentName,\n                componentId,\n            });\n        }\n    }\n\n    /**\n     * Get render history for a component\n     */\n    getComponentHistory(componentId: string): RenderEvent[] {\n        return Array.from(this.renderHistory.values())\n            .filter(event => event.componentId === componentId)\n            .sort((a, b) => a.timestamp - b.timestamp);\n    }\n\n    /**\n     * Get all render history\n     */\n    getAllHistory(): RenderEvent[] {\n        return Array.from(this.renderHistory.values())\n            .sort((a, b) => a.timestamp - b.timestamp);\n    }\n\n    /**\n     * Get recent renders (last N)\n     */\n    getRecentRenders(limit: number = 50): RenderEvent[] {\n        return Array.from(this.renderHistory.values())\n            .sort((a, b) => b.timestamp - a.timestamp)\n            .slice(0, limit);\n    }\n\n    /**\n     * Get component hierarchy tree\n     */\n    getHierarchy(): ComponentHierarchyNode[] {\n        return Array.from(this.componentHierarchy.values())\n            .filter(node => !node.parent);\n    }\n\n    /**\n     * Get a specific component node\n     */\n    getComponentNode(componentId: string): ComponentHierarchyNode | undefined {\n        return this.componentHierarchy.get(componentId);\n    }\n\n    /**\n     * Get render count for a component\n     */\n    getRenderCount(componentId: string): number {\n        return this.componentRenderCounts.get(componentId) ?? 0;\n    }\n\n    /**\n     * Clear all tracking data\n     */\n    clear(): void {\n        this.renderHistory.clear();\n        this.componentHierarchy.clear();\n        this.componentRenderCounts.clear();\n        globalPerformanceMonitor.clearMetrics();\n    }\n\n    /**\n     * Export data for debugging/reports\n     */\n    export(): {\n        history: RenderEvent[];\n        hierarchy: ComponentHierarchyNode[];\n        metrics: ReturnType<typeof globalPerformanceMonitor.getAllMetrics>;\n    } {\n        return {\n            history: this.getAllHistory(),\n            hierarchy: this.getHierarchy(),\n            metrics: globalPerformanceMonitor.getAllMetrics(),\n        };\n    }\n}\n\n// Global singleton instance\nexport const globalRenderTracker = new RenderTracker();\n"],"mappings":"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","names":[]}